
我会仔细查看图像中的符号，并为每个场景设计协议。

## 可用符号总结：

- 对称加密/解密：EK(m)E_K(m)EK​(m), DK(c)D_K(c)DK​(c)
- 公钥加密/解密：EncPubA(m)Enc_{Pub_A}(m)EncPubA​​(m), DecPrivA(c)Dec_{Priv_A}(c)DecPrivA​​(c)
- 签名/验证：SignPrivA(m)Sign_{Priv_A}(m)SignPrivA​​(m), VerPubA(σ)Ver_{Pub_A}(\sigma)VerPubA​​(σ)
- 哈希：H(m)H(m)H(m)
- 时钟：tclockAt^A_{clock}tclockA​, tclockBt^B_{clock}tclockB​
- Nonce：NAN_ANA​, NBN_BNB​
- RNG：生成随机数

---
# Exercise 1 Symmetric Key Security Protocols 
## 问题a  

**协议：**

A侧：

- σ←SignPrivA(m)\sigma \leftarrow Sign_{Priv_A}(m)σ←SignPrivA​​(m)
- A→B:(m,σ)A \rightarrow B: (m, \sigma)A→B:(m,σ)

B侧：

- 接收 (m,σ)(m, \sigma)(m,σ)
- Success/Failure←VerPubA(σ)Success/Failure \leftarrow Ver_{Pub_A}(\sigma)Success/Failure←VerPubA​​(σ)
- 若Success，接受m；否则拒绝

**说明：** A用私钥对测量值签名，B用A的公钥验证签名来确认消息源的真实性。

---

## 问题b 

**协议：**

A侧（对于第i个测量）：

- h←H(mi∣∣tclockA)h \leftarrow H(m_i || t^A_{clock})h←H(mi​∣∣tclockA​)
- σ←SignPrivA(h)\sigma \leftarrow Sign_{Priv_A}(h)σ←SignPrivA​​(h)
- A→B:(mi,tclockA,σ)A \rightarrow B: (m_i, t^A_{clock}, \sigma)A→B:(mi​,tclockA​,σ)

B侧：

- 接收 (mi,tclockA,σ)(m_i, t^A_{clock}, \sigma)(mi​,tclockA​,σ)
- 检查 tclockA==tclockBt^A_{clock} == t^B_{clock}tclockA​==tclockB​ （允许小误差）
- h←H(mi∣∣tclockA)h \leftarrow H(m_i || t^A_{clock})h←H(mi​∣∣tclockA​)
- Success/Failure←VerPubA(σ)Success/Failure \leftarrow Ver_{Pub_A}(\sigma)Success/Failure←VerPubA​​(σ)
- 验证成功且时间戳新鲜则接受

**说明：** 时间戳提供新鲜性，签名保证完整性和认证性。序列通过时间戳排序验证。

---

## 问题c

**协议：**

A侧初始化：

- RNG→seqRNG \rightarrow seqRNG→seq
- seq←0seq \leftarrow 0seq←0

A侧（每次测量）：

- seq←seq+1seq \leftarrow seq + 1seq←seq+1
- σ←SignPrivA(mi∣∣seq)\sigma \leftarrow Sign_{Priv_A}(m_i || seq)σ←SignPrivA​​(mi​∣∣seq)
- A→B:(mi,seq,σ)A \rightarrow B: (m_i, seq, \sigma)A→B:(mi​,seq,σ)

B侧：

- 接收 (mi,seq,σ)(m_i, seq, \sigma)(mi​,seq,σ)
- 检查 seq==expected_seqseq == expected\_seqseq==expected_seq
- Success/Failure←VerPubA(σ)Success/Failure \leftarrow Ver_{Pub_A}(\sigma)Success/Failure←VerPubA​​(σ) 对 (mi∣∣seq)(m_i || seq)(mi​∣∣seq)
- 验证成功则 expected_seq←expected_seq+1expected\_seq \leftarrow expected\_seq + 1expected_seq←expected_seq+1，接受mim_imi​

**说明：** 用序列号替代时间戳保证顺序和新鲜性，防止重放攻击。

---

## 问题d

**协议：**

A侧：

- RNG→seqRNG \rightarrow seqRNG→seq; seq←seq+1seq \leftarrow seq + 1seq←seq+1
- c←EKAB(mi∣∣seq)c \leftarrow E_{K_{AB}}(m_i || seq)c←EKAB​​(mi​∣∣seq)
- σ←SignPrivA(c)\sigma \leftarrow Sign_{Priv_A}(c)σ←SignPrivA​​(c)
- A→B:(c,σ)A \rightarrow B: (c, \sigma)A→B:(c,σ)

B侧：

- 接收 (c,σ)(c, \sigma)(c,σ)
- Success/Failure←VerPubA(σ)Success/Failure \leftarrow Ver_{Pub_A}(\sigma)Success/Failure←VerPubA​​(σ)
- 若Success：mi∣∣seq←DKAB(c)m_i || seq \leftarrow D_{K_{AB}}(c)mi​∣∣seq←DKAB​​(c)
- 检查 seq==expected_seqseq == expected\_seqseq==expected_seq
- 验证通过则接受mim_imi​，更新expected_seqexpected\_seqexpected_seq

**说明：** 对称加密保证机密性，签名保证认证和完整性，seq在密文内防止篡改。

---

## 问题e

**协议：**

A侧：

- RNG→seqRNG \rightarrow seqRNG→seq; seq←seq+1seq \leftarrow seq + 1seq←seq+1
- c←EKABc(mi∣∣seq)c \leftarrow E_{K^c_{AB}}(m_i || seq)c←EKABc​​(mi​∣∣seq)
- h←H(c)h \leftarrow H(c)h←H(c)
- σ←SignPrivA(h)\sigma \leftarrow Sign_{Priv_A}(h)σ←SignPrivA​​(h)
- mac←EKABa(σ)mac \leftarrow E_{K^a_{AB}}(\sigma)mac←EKABa​​(σ)
- A→B:(c,mac)A \rightarrow B: (c, mac)A→B:(c,mac)

B侧：

- 接收 (c,mac)(c, mac)(c,mac)
- σ←DKABa(mac)\sigma \leftarrow D_{K^a_{AB}}(mac)σ←DKABa​​(mac)
- h←H(c)h \leftarrow H(c)h←H(c)
- Success/Failure←VerPubA(σ)Success/Failure \leftarrow Ver_{Pub_A}(\sigma)Success/Failure←VerPubA​​(σ)
- 若Success：mi∣∣seq←DKABc(c)m_i || seq \leftarrow D_{K^c_{AB}}(c)mi​∣∣seq←DKABc​​(c)
- 检查seq有效性，接受mim_imi​

**说明：** KABcK^c_{AB}KABc​用于加密保证机密性，KABaK^a_{AB}KABa​保护签名，签名基于密文哈希保证完整性和认证性。

# 练习 2 窃听 - 解答

## 问题1

已知信息：

- d(A,E) = 1.5 × d(A,B)
- R(x,y) ∝ 1/d²(x,y)

设 d(A,B) = d，则 d(A,E) = 1.5d。

由于传输速率与距离的平方成反比：

**R(A,B) ∝ 1/d²**

**R(A,E) ∝ 1/(1.5d)² = 1/(2.25d²)**

可得：

- R(A,B) = k/d² （其中 k 为常数）
- R(A,E) = k/(2.25d²)

安全（保密）速率为：

**Rs(A,B) = R(A,B) - R(A,E)**

**Rs(A,B) = k/d² - k/(2.25d²)**

**Rs(A,B) = k/d² × (1 - 1/2.25)**

**Rs(A,B) = k/d² × (1 - 0.444...)**

**Rs(A,B) = k/d² × 0.555...**

**Rs(A,B) = k/d² × (5/9)**

保密传输的百分比为：

**百分比 = Rs(A,B)/R(A,B) × 100%**

**百分比 = (5/9) × 100% ≈ 55.56%**

## 问题2

使用适当的物理层安全编码技术，平均保密传输数据的概率等于可以保密发送的传输部分。

**P(保密) = 5/9 ≈ 0.5556 或 55.56%**

这是因为，当使用适当的技术时，大约 55.56% 的数据可以以安全速率 Rs(A,B) 传输，而其余部分容易被窃听。

## 问题3a

已知：

- 10 个可用信道
- 每个信道传输时长：250 毫秒
- 总传输时间：1 秒
- 1 秒内的跳数：1000 毫秒 / 250 毫秒 = **4 跳**
- 窃听者监控：10 个信道中的 3 个（固定）

若要传输 **100% 保密**，A 必须在所有 4 次跳变中选择 E 未监控的信道。

- 安全信道数量：10 - 3 = 7
- 单次跳变选择安全信道的概率：7/10

由于信道选择是独立的：

**P(100% 保密) = (7/10)⁴**

**P(100% 保密) = 2401/10000 = 0.2401 或 24.01%**

## 问题3b

已知：

- 总传输时间：0.5 秒
- 跳数：500 毫秒 / 250 毫秒 = **2 跳**
- 需要至少 78% 的保密性

根据题目所述，“在受干扰信道中传输保密数据的概率已在第 2 部分计算得出”。

这意味着：

- 若信道未受干扰（E 未监听）：保密概率 = 1 (100%)
- 若信道受干扰（E 正在监听）：保密概率 = 5/9（来自第 2 部分）

对于 2 次跳变且每次跳变时间相等（各占 50%）的情况，若要达到 78% 的保密性：

要求：**平均保密性 ≥ 78%**

设 K = 受干扰信道上的跳数（K 服从二项分布，n=2，p=3/10）

- 若 K = 0（无受干扰跳变）：保密性 = 100% ✓
- 若 K = 1（一次受干扰跳变）：保密性 = (1×50% + (5/9)×50%) = 50% + 27.78% = 77.78% ✗
- 若 K = 2（两次均受干扰）：保密性 = (5/9)×100% = 55.56% ✗

仅 K = 0 满足要求。

**P(K = 0) = C(2,0) × (3/10)⁰ × (7/10)² = 1 × 1 × 49/100**

## **P(至少 78% 保密) = 49/100 = 0.49 或 49%**


----

# Exercise 3 Online Banking DDoS Attack 
**1. SYN Flood Attack**  
总攻击速率 = 2,000 bots × 80 SYN包/秒 = 160,000 SYN包/秒。  
内存消耗速率 = 160,000 连接/秒 × 1.5 MB = 240,000 MB/秒 = 240 GB/秒。  
耗尽时间 = 100 GB (可用内存) / 240 GB/秒 ≈ 0.417 秒。  
**答案：内存将在约 0.42 秒后耗尽。**

**2. HTTP Request Flood Attack**  
带宽消耗 = 8,000 请求/秒 × 2 KB × 8 bits/byte = 128,000 kbps。  
超出容量 = 128,000 kbps - 15,000 kbps (API容量) = 113,000 kbps。  
**答案：带宽消耗为 128,000 kbps，超出 API 容量约 7.5 倍（总流量是容量的 8.53 倍），将导致服务不可用。**

**3. Attack Vector Analysis**  
**技术有效性分析：**  
针对认证服务器，**SYN Flood 攻击更有效**。认证服务器拥有 50,000 个并发会话的高应用层容量，Slowloris 需要较长时间才能填满这一连接池。相比之下，SYN Flood 直接攻击底层网络栈，如计算所示，能在 0.5 秒内耗尽服务器内存，造成立即且灾难性的服务瘫痪，完全无视应用层的处理能力。

**业务后果对比：**  
SYN Flood 会导致服务瞬间完全中断，这种“猝死”虽然破坏力大，但特征明显，便于快速启动应急响应。而 Slowloris 会导致服务质量间歇性下降或逐渐变慢，在“黑色星期五”的高流量背景下，极易被误判为正常的用户激增，导致故障排查延迟，长期的访问受阻会比瞬间宕机造成更严重的客户流失和信任危机。

**4. Defense Prioritization**  
按照 **SYN Cookies -> Rate Limiting -> Traffic Filtering** 的顺序实施防御：

- **第一优先级：SYN Cookies（立即实施）**  
    这是应对最致命攻击（0.42秒内存耗尽）的唯一即时解法。在内核级启用 SYN Cookies 可以让服务器在不消耗内存存储半开连接的情况下处理 SYN 洪水，且对合法用户透明，是确保服务器“存活”的基础。
- **第二优先级：Rate Limiting（限流，1小时内）**  
    服务器存活后，必须解决带宽被 HTTP 洪水（超载 8.5 倍）挤占的问题。通过 IP 限流和令牌桶算法，将请求速率压制在 API 处理能力之内，防止资源被耗尽，为后续的精细化过滤争取空间。
- **第三优先级：Traffic Filtering（流量过滤，4小时内）**  
    在系统稳定后，部署基于行为的过滤（如检查 User-Agent、会话连贯性）来精准剔除混在流量中的 Bot。这能保护后端的交易服务器，并确保真实用户的体验。

放弃 CAPTCHA 是因为其严重影响用户体验且难以满足 3 秒认证时限；放弃单纯的负载均衡是因为它只能分担压力而无法消除攻击流量。_

### 第 5 部分：协议设计 - 客户端谜题认证增强 (8 分)

**设计方案：动态工作量证明（Proof-of-Work）握手协议**

为了防止自动化攻击，我们在处理昂贵的数据库认证操作前，引入一个计算成本不对称的预验证步骤。

1. **协议流程**：
    
    - **请求阶段**：客户端发起登录请求。
    - **挑战阶段**：服务器不立即查询数据库，而是返回一个包含随机数（Nonce）和难度目标（Difficulty）的“谜题”。
    - **计算阶段**：客户端必须进行哈希运算（如 SHA-256），找到一个解，使得 `Hash(Nonce + 解)` 的结果以指定数量的零开头。
    - **验证阶段**：客户端提交解。服务器进行一次哈希验证（极快）。只有验证通过，服务器才处理用户名/密码。
2. **动态难度调整**：
    
    - **正常负载**：难度设为低（如 12 bits），现代手机仅需 0.05 秒计算，用户无感知。
    - **高负载/攻击中**：当服务器负载超过 70% 时，自动提升难度（如 20 bits），计算时间升至 0.5-1.0 秒。
3. **防御效果**：合法用户仅增加不到 1 秒的延迟，体验影响微乎其微；但对于拥有 2,000 个 Bot 的攻击者，计算成本将呈指数级上升，迫使其无法维持每秒 80 次的高频请求，从而保护后端资源。
    

---

### 第 6 部分：合法流量保护策略 (8 分)

**策略：基于信任评分的分级流量管理**

面对黑色星期五每分钟 5,000 次的合法请求，采用“漏斗式”筛选策略，优先保障高价值用户，压制可疑流量。

1. **多维信任评分系统**：
    
    - 对每个连接进行实时打分。加分项：来自北欧地区 IP、通过已知设备指纹访问、有历史交易记录的账户。减分项：数据中心 IP、异常的点击频率、新设备。
2. **三级优先级队列机制**：
    
    - **一级（快速通道 - 30% 容量）**：高分用户（老客户）。直接通过，无额外验证，确保核心用户零延迟体验。
    - **二级（普通通道 - 50% 容量）**：中分用户。需完成低难度客户端谜题（Part 5 设计）方可进入，过滤掉大部分简单脚本。
    - **三级（慢速通道 - 20% 容量）**：低分/可疑用户。强制高难度谜题 + 严格限流（如每 IP 每分钟 5 次），仅在系统空闲时处理。
3. **用户体验保障**：
    
    - 不采用“一刀切”的 IP 封锁，避免误伤使用公共 Wi-Fi 的合法用户。
    - 通过计算成本而非硬性拒绝来调节流量，确保 5,000/分的合法请求能优先占用系统资源，仅让攻击者陷入计算泥潭。

---

### 第 7 部分：服务恢复与未来预防 (8 分)

**服务恢复步骤：**

1. **技术恢复（分阶段重启）**：
    
    - **清理现场**：在防火墙层面刷新所有半开的 TCP 连接，清除攻击残留。
    - **健康检查**：确认数据库连接池和 API 带宽已释放。
    - **灰度上线**：前 5 分钟仅允许“高信任评分”的 IP 访问，确认系统稳定后，再逐步开放给所有用户。
2. **客户沟通**：
    
    - **即时公告**：在 App 和官网发布通知：“服务已全面恢复。您的资金与交易数据绝对安全，未受影响。”
    - **后续安抚**：向受影响期间尝试登录失败的客户发送致歉短信，说明这是为了保护账户安全而触发的防御机制。

**未来预防措施（两项）：**

1. **部署云端流量清洗（Cloud Scrubbing）**：
    
    - 签约如 Cloudflare 或 Akamai 的服务。在流量到达银行基础设施**之前**，利用云厂商庞大的带宽清洗掉 SYN 洪水和体积型攻击，只将干净的流量回源到银行服务器。
2. **实施基于机器学习的智能限流**：
    
    - 部署异常检测 AI，学习正常用户的行为模式（如页面停留时间、鼠标轨迹）。不再依赖固定的“每秒 N 次”规则，而是自动识别并拦截具备“僵尸网络特征”的复杂应用层攻击。

----
# Exercise 4 Firewalls 
## 问题 1：

无状态防火墙是指独立检查每个数据包，而不跟踪连接状态或数据包历史的防火墙。其主要特点是仅基于数据包头信息（如源/目的 IP、端口和协议）做出决定，对之前的数据包没有记忆。虽然这种处理方式速度较快，但由于每个数据包都是根据规则独立评估的，缺乏对流量上下文的理解，因此智能程度较低。

有状态防火墙通过维护一个连接表来跟踪网络连接的状态。它们能够记住之前的数据包和连接上下文，并跟踪如 SYN 或 ESTABLISHED 等 TCP 连接状态。由于能够根据连接历史做出决定并理解流量流动的上下文，这类防火墙通常被认为更加安全

**有状态防火墙通常被认为更好**。这是因为它们通过理解连接上下文提供了更佳的安全性，能够自动允许已建立连接的返回流量，并防止诸如伪造数据包声称属于已建立连接等特定攻击。

## 问题2:
|#|方向 (DIRECTION)|源 (SOURCE)|目的 (DESTINATION)|协议 (PROTOCOL)|源端口 (SRC PORT)|目的端口 (DST PORT)|状态 (STATE)|动作 (ACTION)|
|---|---|---|---|---|---|---|---|---|
|1|IN/OUT|*|*|UDP|*|*|-|REJECT|
|2|IN|207.46.130.0/24|*|*|*|*|-|REJECT|
|3|OUT|*|69.171.239.12|TCP|*|80|-|REJECT|
|4|IN|64.233.160.0/24|*|TCP|*|80|-|ACCEPT|
|5|IN|*|*|ICMP|-|-|-|REJECT|
|6a|OUT|*|*|TCP|*|80|NEW/EST|ACCEPT|
|6b|IN|*|*|TCP|80|*|EST|ACCEPT|
|7a|IN|64.233.160.0/24|*|TCP|*|22|NEW/EST|ACCEPT|
|7b|OUT|*|*|TCP|*|22|NEW|REJECT|
|7c|OUT|*|*|TCP|22|*|EST|ACCEPT|

# Exercise 5 Password Management 
## 问题 a

使用公式 $H = L \cdot \log_2 N$：

- $L = 10$（密码长度）
- $N = 256$（ASCII 字符集大小）

**计算：**  
$H = 10 \cdot \log_2(256)$  
$H = 10 \cdot \log_2(2^8)$  
$H = 10 \cdot 8$  
**$H = 80$ 比特**

10 个字符的 ASCII 密码的熵为 **80 比特**。

## 问题 b

**密码 1：12 个字符，十六进制（HEX）符号**

- $L = 12$
- $N = 16$ (0-9, A-F)
- $H_1 = 12 \cdot \log_2(16) = 12 \cdot 4 = \textbf{48 比特}$

**密码 2：10 个字符，Base32 符号**

- $L = 10$
- $N = 32$ (A-Z, 2-7)
- $H_2 = 10 \cdot \log_2(32) = 10 \cdot 5 = \textbf{50 比特}$

**答案：** 10 个字符的 Base32 密码（50 比特）比 12 个字符的 HEX 密码（48 比特）**更能抵抗**暴力破解攻击，尽管两者的差异相对较小。

## 问题 c

**字典攻击定义：**  
字典攻击使用预先编译好的可能密码列表（常用词、短语、已知泄露的密码、带有常见替换如 "p@ssw0rd" 的变体），而不是尝试所有可能的组合。

**主要区别：**

- **字典攻击**：仅测试词表中概率较高/常见的密码。
- **暴力破解攻击**：系统地尝试每一个可能的字符组合。

**字典攻击更有效的场景：**  
当用户选择人类易于记忆的密码时，如 "Summer2024!"、"iloveyou" 或 "Password123"。这些密码出现在密码字典中，可以被快速发现（几分钟/几小时），相比之下，暴力破解整个搜索空间（例如 10 个字符的字母数字组合，$62^{10} \approx 83.9$ 亿亿种可能性）需要天文数字般的时间。

**暴力破解更有效的场景：**  
当密码是真正的随机密码时，例如由密码管理器生成的 "xK9#mQ2$pL"。这种密码不会出现在任何字典中，使得字典攻击无效。虽然暴力破解在计算上仍然昂贵，但这成为了唯一可行的方法（尽管在熵足够高的情况下仍然是不切实际的）。

## 问题 d

**盐（Salts）的作用：**  
盐是在哈希之前附加到密码上的随机值。它确保相同的密码对于不同的用户产生不同的哈希值。

**缓解的攻击：**

1. **彩虹表攻击（Rainbow Table Attacks）**：预先计算的哈希表变得无用，因为每个“密码-盐”组合都会产生唯一的哈希值。
2. **并行破解（Parallel Cracking）**：攻击者无法同时破解多个相同的密码。
3. **相同密码检测**：防止泄露哪些用户共享相同的密码。

**总搜索空间计算：**

- 密码空间：$256^{10}$（10 个 ASCII 字符）
- 盐空间：$2^{128}$（128 位盐）
- **总搜索空间 = $256^{10} \times 2^{128}$**

然而，需要注意的是，实际上攻击者一次只针对一个“密码-盐”对进行攻击，因此每个密码的有效搜索空间仍然是 $256^{10}$。盐的作用是防止将攻击成本分摊到多个用户身上。

## 问题 e

**KDF 相比单一哈希的优势：**

1. **计算成本**：KDF 将哈希函数迭代数千/数百万次，使得每一次密码猜测都很昂贵。
2. **内存硬度（Memory hardness）**：某些 KDF（如 scrypt, Argon2）还需要大量内存，限制了 GPU/ASIC 的优势。
3. **可参数化的工作因子**：随着硬件的进步，可以增加迭代次数。
4. **内置加盐**：KDF 包含正确的盐管理机制。

**计算：**

**总可能密码数：**

- 8 个 ASCII 字符：$256^8 = \textbf{18,446,744,073,709,551,616}$ ($\approx 1.84 \times 10^{19}$)
- 64 位的盐不会改变这一点；它防止了彩虹表，但每个用户的密码仍然有 $256^8$ 种可能性。

**不带迭代的时间（每个密码 1 次哈希）：**

- 平均搜索空间 = $256^8 / 2 = 9.22 \times 10^{18}$
- 时间 = $(9.22 \times 10^{18}) / 100,000$ 哈希/秒
- 时间 = $9.22 \times 10^{13}$ 秒 = **292 万年**

**带 100,000 次迭代的时间：**

- 每个密码猜测需要 100,000 次哈希
- 有效速率 = $100,000 / 100,000$ = **1 个密码/秒**
- 时间 = $(256^8 / 2) / 1$ 个密码/秒
- 时间 = $9.22 \times 10^{18}$ 秒 = **2920 亿年**

## 问题 f

**识别出的弱点：**

1. **无迭代**：仅使用 2 次 SHA-256 操作，使其速度几乎与单次哈希一样快，对暴力破解的抵抗力极低。
2. **密码哈希在加盐前计算**：中间哈希值 `h = SHA256(password)` 独立于盐，因此相同的密码总是产生相同的 `h`。这部分可以被预先计算。

**改进后的伪代码：**


```python
password = "NoPs007lkj"

salt := random_bits(128)  

iterations := 100000  

key := PBKDF2(
    hash_function=SHA256,
    password=password,
    salt=salt,
    iterations=iterations,
    output_length=32 
)

store(salt, key, iterations)
```


# Exercise 6 Secure Link-State Routing
# 问题 1

在网络正常且稳定的状态下，路由器 D 到达路由器 A 的最短路径应为 D → F → E → A。根据图中标注的链路权重，该路径的总开销为 cost(D,F) + cost(F,E) + cost(E,A) = 5 + 5 + 8 = 18。相比之下，另一条路径 D → C → B → A 的开销为 5 + 10 + 10 = 25，因此 D 会优先选择经过 F 和 E 的路径。

当故障路由器 B 广播错误的链路状态更新（LSU），声称 cost(B,A)=1 和 cost(B,C)=1 时，D 接收到此信息并重新计算路由。D 会发现通过 C 到达 B 再到 A 的路径开销变为：cost(D,C) + cost(C,B) + cost(B,A) = 5 + 10 + 1 = 16（此处假设 D 采纳了 B 声称的低成本连接）。由于 16 小于原始最优路径的 18，D 会错误地认为 D → C → B → A 是最优路径。因此，源自 D 且发往 A 的数据包将被错误地路由到 C，进而转发给 B。如果 B 处于故障状态，数据包可能会在 B 处丢失；即使 B 能够转发，数据流也被引向了本不应经过的链路，导致网络拥塞或次优路由。

# 问题 2

当 C 和 A 重新发送包含正确成本（即 cost(C,B)=10 和 cost(A,B)=10）的 LSU 后，网络中的链路状态数据库（LSDB）将出现不一致。故障路由器 B 持续声称与 A、C 的连接成本为 1，而 A 和 C 则声称成本为 10。这种矛盾信息会导致网络处于不稳定状态。

这种情况对网络是极其负面的。路由器 D 和其他节点会收到相互冲突的拓扑信息，导致路由计算频繁波动（即路由震荡）。路由器可能在短时间内多次更改路由表，消耗大量的 CPU 资源进行最短路径计算，并占用带宽传播更新信息。此外，这种状态可能导致临时的路由环路或数据包在网络中无限循环，严重影响数据传输的可靠性和网络的整体性能。

# 问题 3

为了验证签名者的公钥确实属于声称的签名者，网络必须建立公钥基础设施（PKI）。核心要求是引入一个受信任的第三方，即证书颁发机构（CA）。每个路由器都需要向 CA 注册，并获得由 CA 数字签名的公钥证书。该证书将路由器的身份（如 Router ID）与其公钥进行加密绑定。

在验证过程中，接收 LSU 的路由器使用预先安装的 CA 根公钥（信任锚）来验证发送者证书上的 CA 签名。如果 CA 签名验证通过，则证明该证书未被伪造，且证书中包含的公钥确实属于该路由器。通过这种信任链机制，路由器可以确信用于验证 LSU 签名的公钥是真实且合法的。

# 问题 4

为了确保接收到的数字签名 LSU 是新鲜的（Freshness），即防止重放攻击（Replay Attack），必须在 LSU 消息格式中引入序列号（Sequence Number）和时间戳（Timestamp）机制，或者设置生存时间（Age/TTL）。

最常用的方法是使用单调递增的序列号。每个路由器维护一份记录，存储从每个邻居接收到的最新 LSU 的序列号。当收到新的 LSU 时，路由器会比对序列号：只有当新收到的 LSU 序列号大于本地缓存的序列号时，才会被视为新消息并接受；否则将被丢弃。此外，结合同步时钟的时间戳或规定消息在网络中的最大生存时间，可以进一步确保消息在有效时间窗口内，防止攻击者截获并重放旧的路由信息。

# 问题 5

数字签名无法防止问题 1 中描述的故障影响。这是因为数字签名的作用是确保数据的“完整性”和“来源认证”，即证明该信息确实是由路由器 B 发送的，且在传输过程中未被篡改。然而，数字签名无法验证数据内容的“正确性”。在问题 1 的场景中，B 是一个拥有合法私钥的认证路由器，它对其生成的错误内容（cost=1）进行了正确的签名。其他路由器在验证签名时会通过，因为签名本身是有效的，从而接受了错误的路由信息。

尽管如此，数字签名在对抗故障或恶意路由器方面仍具有显著优势。首先，它提供了不可否认性（Non-repudiation），网络管理员可以确凿地追踪到错误信息的源头是路由器 B，从而快速定位故障。其次，它防止了外部攻击者伪造 LSU 注入网络，也防止了中间节点（如路由器 E）在转发过程中恶意篡改 LSU 的内容。因此，虽然它不能解决合法路由器的逻辑错误或撒谎问题，但它有效地构建了网络的可信身份层和防篡改层。


# Exercise 7 RPKI and ROA 

## 问题1


**1. 通告：122.3.12.0/24, AS 路径 (ASPATH): AS 123, AS 341**

- **源 AS (Origin AS)：** AS 341
- **前缀 (Prefix)：** 122.3.12.0/24
- **分析：** 该前缀被 VRP1 (122.3.0.0/16) 覆盖。源 AS (341) 与 VRP 匹配。然而，前缀长度 (/24) 大于允许的最大长度 (maxlength: 16)。
- **结果：INVALID（无效）**

**2. 通告：124.5.0.0/16, AS 路径 (ASPATH): AS 341, AS 134**

- **源 AS (Origin AS)：** AS 134
- **前缀 (Prefix)：** 124.5.0.0/16
- **分析：** 该前缀与 VRP2 完全匹配。源 AS (134) 与 VRP 匹配。前缀长度 (/16) 在允许的最大长度 (24) 范围内。
- **结果：VALID（有效）**

**3. 通告：124.5.192.0/18, AS 路径 (ASPATH): AS 413, AS 134**

- **源 AS (Origin AS)：** AS 134
- **前缀 (Prefix)：** 124.5.192.0/18
- **分析：** 该前缀是 VRP2 (124.5.0.0/16) 的子网。源 AS (134) 与 VRP 匹配。前缀长度 (/18) 小于或等于允许的最大长度 (24)。
- **结果：VALID（有效）**

**4. 通告：122.5.0.0/16, AS 路径 (ASPATH): AS 312, AS 341**

- **源 AS (Origin AS)：** AS 341
- **前缀 (Prefix)：** 122.5.0.0/16
- **分析：** 没有 VRP 覆盖前缀 122.5.0.0/16。VRP1 覆盖的是 122.3.0.0/16，与 122.5.0.0/16 没有重叠。
- **结果：UNKNOWN（未知/未找到）**

**5. 通告：124.5.0.0/16, AS 路径 (ASPATH): AS 341, AS 123, AS 134, AS 413**

- **源 AS (Origin AS)：** AS 413
- **前缀 (Prefix)：** 124.5.0.0/16
- **分析：** 该前缀被 VRP2 覆盖。然而，通告中的源 AS 是 AS 413，而 VRP2 中授权的源 AS 是 AS 134。
- **结果：INVALID（无效）**

---

## 问题2



- **通告 1：排除。** 它是 RPKI **INVALID（无效）** 的。
- **通告 2：排除。** 虽然它是 RPKI **VALID（有效）** 的，但在拓扑上是 **IMPLAUSIBLE（不合理）** 的。
    - _理由：_ AS 路径为 `AS 341, AS 134`。这意味着 AS 341 直接从 AS 134 接收了路由。然而，观察图 1 可知，AS 341 和 AS 134 **没有直接连接**。它们必须通过中间节点（如 AS 123）进行通信，而该路径中缺失了中间节点。
- **通告 3：包含。** 它是 **有效且合理** 的。
    - _理由：_ 它是 RPKI 有效的（见第一部分）。AS 路径为 `AS 413, AS 134`。图 1 显示 AS 413 和 AS 134 之间存在直接物理链路，使得该路径在拓扑上是正确的。
- **通告 4：排除。** 它是 RPKI **UNKNOWN（未知）** 的。
- **通告 5：排除。** 它是 RPKI **INVALID（无效）** 的。

**结论：**  
只有 **通告 3** 既有效又合理。