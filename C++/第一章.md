# 类
## 1. 声明：
class CComplex;

## 2.定义
class CComplex
{
	double mR, mI;
Public:
void SetValue 9doubel zR, double zI);
}

不在Public里面的就是私有的，无法被类以外的东西访问

尽量不要在类里面定义具体的函数，仅声明

使用：
CComplex ZC;
ZC.Setvalue(a, b);
是可以的
cout<<ZC.mR<<endl;
这个不行，访问了私有内容

void CComplex::SetValue(double zR, double zI)
{
mR=zR; mI=zI
}

## 3. 栈空间
栈为一种先进后出的数据结构，函数内定义的局部变量及函数参数都在栈空间分配
栈空间中的内存连续分配，数据的地址顺序与数据分配的先后顺序相反
每个县城（程序）的栈空间独立且大小有限，栈空间可能溢出
所以不要在函数内部定义大型数组，不能调用嵌套层次过多的递归数组

## 4.struct . ->
. ->都可以引用struct对象会指针的成员

## 5.内联函数
inline bool max(int a, int b){
return a<b;
}

如果为内联函数，则调用时是直接把代码复制过去，避免了进出函数的开销，但是如果过长就会导致代码量过多或执行速度变慢 不要超过10行，别有复杂语法

##### \*指针使用时一定要先初始化，一种为new，一种为 =&a

int* ptr = new int; // ptr指向一个新分配的int类型的内存


int a = 10;
int* ptr = &a; // ptr指向变量a的地址

## 6.有参宏
define max(a, b) a>b?a:b;

**域作用符：如果前面无其他内容，就表示全局域（：：i）

**名字空间：namespace

## 7.外部链接
extend int Value;
可以不初始化，作用域为全局，并且为声明，可以不初始化

如果为extend const int Value；
就必须初始化，且之后不能修改

**char* const pContent; 指针常量，不能修改指针指向的值
const char* pContent;常量指针，不能通过指针来改变所指的内容

## 8.构造函数
不能显式调用，析构函数可以
如果没有定义系统也会生成
CComplex::CComplex(){

}

## 9.struct参数
struct string{char \*ps}{

}
struct string{char ps\[10]}{

}

即使数组名是ps为地址名，但是传到函数中时要重新复制

## 10. new delete
int \*pScore1, \*pScore2, \*pScore3;
pScore1 = new int;
pScore2 = new int(38);\\\\赋值该区域为38
pScore3=new int\[10];\\\\长度为10的数组

\*可以用于任何数据结构
\*delete数组时，要写delete \[]pComplex，就会delete整体数组，否则可能出现内存问题，尤其是对于类的数组

delete之后要将指针指向NULL

拷贝构造函数中要使用一个新的地址，否则在这个对象析构之后原对象中的地址会失效

析构函数要delete + ->NULL




