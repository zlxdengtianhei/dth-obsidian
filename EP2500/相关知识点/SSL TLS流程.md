
![[f0bb245425515fc31e67f2886ddb091e.jpg]]
### 一、TLS/SSL 握手：目标与背景

首先，我们要明确 TLS/SSL 握手的**三大核心目标**：

1. **身份验证 (Authentication)**: 客户端需要确认与之通信的服务器是它声称的那个服务器（例如，确认 `www.mybank.com` 真的是银行的服务器），而不是一个中间人攻击者。这是握手过程中最关键的安全环节。
2. **协商加密套件 (Cipher Suite Negotiation)**: 客户端和服务器需要商定一套双方都支持的加密算法，用于后续的通信。这就像两个人见面，先商量好要用哪种语言（和方言）对话。
3. **密钥交换 (Key Exchange)**: 双方需要安全地生成并共享一个用于本次会话的**对称密钥（Session Key）**。握手过程本身使用非对称加密，但一旦握手成功，后续所有应用数据的加密都将使用这个更高效的对称密钥。

**关于 SSL 和 TLS**: SSL (Secure Sockets Layer) 是早期版本，存在一些安全漏洞。TLS (Transport Layer Security) 是其继任者，是目前使用的标准。我们通常说的 SSL 握手，现在指的都是 TLS 握手。TLS 1.2 和 TLS 1.3 是当前最主流的版本，它们的握手流程略有不同，这里我们以更经典、更易于理解 PKI 概念的 **TLS 1.2** 为例进行讲解。

---

### 二、TLS 1.2 握手完整流程（分步详解）

整个握手过程就是客户端和服务器之间的一系列消息交换。

#### **阶段一：打招呼与协商**

**第1步: `ClientHello` (客户端 → 服务器)**

- **内容**: 客户端向服务器发送第一条消息，表明“你好，我想建立安全连接”。
    - **支持的 TLS 版本**: 客户端告诉服务器它最高支持哪个 TLS 版本（如 TLS 1.2, 1.3）。
    - **客户端随机数 (Client Random)**: 一个由客户端生成的 32 字节的随机数，用于后续生成会话密钥。
    - **会话 ID (Session ID)**: 如果客户端之前与该服务器建立过连接，可以发送之前的会话 ID，尝试进行“会话恢复”，跳过完整的握手过程。
    - **支持的加密套件列表 (Cipher Suites)**: 这是客户端支持的所有加密算法组合的列表，按偏好顺序排列。一个加密套件通常包括：密钥交换算法、身份验证算法、对称加密算法和哈希算法。
- **比喻**: 你走进一家餐厅，对服务员说：“你好，我懂中文和英文（TLS 版本），我想点菜。这是我的菜单偏好列表（加密套件列表），你看看能做什么菜。”

**第2步: `ServerHello` (服务器 → 客户端)**

- **内容**: 服务器收到客户端的问候后，做出回应。
    - **选定的 TLS 版本**: 服务器从客户端支持的版本中选择一个自己也支持的最高版本。
    - **服务器随机数 (Server Random)**: 服务器也生成一个 32 字节的随机数。
    - **选定的加密套件**: 服务器从客户端的列表中选择一个自己也支持且安全性高的加密套件。
    - **会话 ID**: 如果服务器同意会话恢复，会返回相同的会话 ID。
- **比喻**: 服务员回答：“好的，我们今天就用中文（选定 TLS 版本）交流。根据你的偏好，我们决定做这道‘宫保鸡丁’（选定加密套件）。”

---

#### **阶段二：服务器身份验证与密钥交换准备**

这是整个握手过程的核心，也是 PKI 发挥作用的地方。

**第3步: `Certificate` (服务器 → 客户端)**

- **内容**: 服务器将其**数字证书**（或一个证书链）发送给客户端。这个证书包含了服务器的公钥和身份信息（如域名），并且由某个 CA 进行了数字签名。
- **目的**: 这是服务器向客户端证明自己身份的关键一步。

**第4步: `ServerKeyExchange` (服务器 → 客户端) (可选)**

- **内容**: 在某些密钥交换算法（如 DHE/ECDHE）中，仅有证书中的公钥是不够的。服务器需要在这里发送额外的密钥交换参数，并用自己的**私钥**对这些参数进行**数字签名**。
- **目的**:
    1. 提供密钥交换所需的额外数据。
    2. **至关重要的一步**：通过签名证明自己确实拥有证书中公钥对应的那个私钥。这被称为“所有权证明”。

**第5步: `ServerHelloDone` (服务器 → 客户端)**

- **内容**: 一个简单的消息，告诉客户端：“好了，我这边该说的都说完了，现在轮到你了。”

---

### 三、深入解析：核心认证过程（客户端的工作）

当客户端收到服务器发来的 `Certificate` 和 `ServerKeyExchange` 消息后，它会执行一系列严格的验证步骤，这正是你关心的详细认证过程：

1. **检查证书链 (Trust Chain Validation)**:
    
    - 客户端会查看服务器发来的证书链。通常这包括服务器自身的**终端实体证书**和一个或多个**中间 CA 证书**。
    - 客户端从服务器证书开始，用签发该证书的中间 CA 的公钥来验证其签名。
    - 接着，再用更上一级 CA 的公钥，验证这个中间 CA 证书的签名。
    - 这个过程会一直持续，直到追溯到一个**根 CA 证书**。
    - 最后，客户端会在自己内置的**根证书库 (Root Store)** 中查找这个根 CA。如果找到了，并且该根 CA 是受信任的，那么整条证书链就被认为是可信的。这就像我们之前比喻的，确认“员工”的身份最终要追溯到受信任的“CEO”。
2. **检查证书有效期**: 客户端会检查证书是否在当前日期时间的有效期内，确保证书没有过期或尚未生效。
    
3. **检查域名匹配**: 客户端会检查证书中的“主题”或“主题备用名称 (SAN)”字段，看其中列出的域名是否与自己当前正在访问的域名（如 `www.mybank.com`）完全匹配。如果不匹配，浏览器会发出严重的安全警告。
    
4. **检查证书吊销状态**:
    
    - 客户端会通过 **OCSP (在线证书状态协议)** 或 **CRL (证书吊销列表)** 机制，向签发证书的 CA 查询该证书是否已被吊销（例如因为私钥泄露）。如果证书已被吊销，连接会立即中断。
5. **验证服务器的所有权证明 (Proof of Possession)**:
    
    - 如果服务器发送了 `ServerKeyExchange` 消息，客户端会使用服务器证书中的**公钥**来解密该消息中的**数字签名**。
    - 如果解密成功，并能得到与消息内容匹配的哈希值，就证明了服务器**确实持有与证书公钥配对的私钥**。
    - **这是防止攻击者盗用证书的关键**。即使攻击者窃取了 `mybank.com` 的证书文件，但他没有对应的私钥，就无法完成这一步签名验证，从而暴露自己是冒牌货。

**只有以上所有步骤全部验证通过，客户端才会信任该服务器的身份。**

---

#### **阶段三：客户端回应与生成会话密钥**

**第6步: `ClientKeyExchange` (客户端 → 服务器)**

- **内容**: 客户端现在需要生成一个用于创建会话密钥的“种子”，并安全地发送给服务器。
    - 客户端生成一个随机数，称为 **Pre-Master Secret**。
    - 客户端使用从服务器证书中获取的**服务器公钥**，对这个 **Pre-Master Secret** 进行加密。
- **目的**: 安全地将 Pre-Master Secret 发送给服务器。由于只有持有私钥的服务器才能解密，所以即使被窃听，中间人也无法得知 Pre-Master Secret 的内容。

**第7步: `ChangeCipherSpec` (客户端 → 服务器)**

- **内容**: 一个简单的通知，告诉服务器：“从现在开始，我将使用我们之前商量好的加密套件和刚刚生成的密钥来加密通信了。”

**第8步: `Finished` (客户端 → 服务器)**

- **内容**: 这是客户端发送的第一条**加密消息**。它包含了之前所有握手消息的哈SHI值，并使用刚刚生成的**会话密钥**进行加密。
- **目的**:
    1. 向服务器确认密钥生成和加密过程一切正常。
    2. 验证到目前为止的所有握手消息都没有被中间人篡改。

---

#### **阶段四：服务器完成握手**

**第9步: 服务器解密与验证**

- 服务器收到客户端的 `ClientKeyExchange` 消息后，使用自己的**私钥**解密，得到 **Pre-Master Secret**。
- 现在，客户端和服务器都拥有了三个相同的随机数：**Client Random**、**Server Random** 和 **Pre-Master Secret**。双方使用完全相同的算法，将这三个数混合计算，生成一个最终的**主密钥 (Master Secret)**。
- 然后，再从主密钥派生出会话所需的所有密钥：用于加密的对称密钥、用于验证消息完整性的 MAC 密钥等。

**第10步: `ChangeCipherSpec` (服务器 → 客户端)**

- **内容**: 服务器也发送这个通知，告诉客户端：“好的，收到。我也准备好了，从现在起开始加密通信。”

**第11步: `Finished` (服务器 → 客户端)**

- **内容**: 服务器也发送自己的 `Finished` 消息，同样包含之前所有握手消息的哈希值，并用**会话密钥**加密。
- **目的**: 让客户端验证服务器侧的密钥生成和加密过程也一切正常，并且握手消息未被篡改。

---

### 四、握手结束，安全通信开始

一旦双方都成功验证了对方的 `Finished` 消息，TLS 握手就正式完成。此时：

- 服务器的身份已经得到验证。
- 双方已经协商好了一套安全的加密算法。
- 双方已经共享了一个只有他们自己知道的、安全的对称会话密钥。

从此以后，客户端和服务器之间传输的所有应用数据（如 HTTP 请求和响应、网页 HTML、图片等）都会使用这个会话密钥进行加密和解密，实现了真正意义上的安全通信。

### 五、涉及的协议与实现方法

- **协议**:
    
    - **TLS 记录协议 (Record Protocol)**: 负责将上层数据（如 HTTP）分块、压缩、加密，并附加消息认证码 (MAC)，然后交给下层 TCP 传输。
    - **TLS 握手协议 (Handshake Protocol)**: 就是我们上面详细描述的整个流程，负责身份认证、协商和密钥交换。它运行在记录协议之上。
    - **TLS 警报协议 (Alert Protocol)**: 用于在发生错误时（如证书验证失败、解密错误等）向对方发送警报消息。
    - **TLS 变更密码规范协议 (Change Cipher Spec Protocol)**: 就是那个简单的 `ChangeCipherSpec` 消息，用于通知对方切换到加密模式。
- **实现方法**:
    
    - TLS/SSL 功能通常不是由应用程序开发者从零开始编写的，而是通过使用成熟的**安全库**来实现。
    - 最著名的实现库是 **OpenSSL**，它是一个开源的、功能强大的密码学和 TLS 实现库。几乎所有的 Linux Web 服务器（如 Apache, Nginx）都依赖它。
    - 其他实现还包括 **BoringSSL** (Google Fork 的 OpenSSL)、**LibreSSL** (OpenBSD Fork 的 OpenSSL) 以及 Windows 自带的 **SChannel** 等。
    - 应用程序（如 Web 服务器、浏览器、邮件客户端）通过调用这些库提供的 API 来完成 TLS 握手和数据加解密，从而轻松实现安全通信。

23:52


请你告诉我，这个一开始的hello中的随机数，与后续阶段三中，提到的随机数，作为创建会话密钥的种子有什么区别？为什么第六步还在说生成一个创建会话密钥的种子，第七部就已用上了密钥？所以说第六步中客户端还会直接计算得到密钥吗？这个密钥的计算具体是怎么完成？


非常好的问题！这恰恰是 TLS 握手过程中最精妙也最容易混淆的地方。你准确地指出了一个看似矛盾的时间点：为什么刚把“种子”送出去，马上就能用最终的密钥了？

我来为你详细拆解这个过程，解答你的所有疑问。

### 一、三种“随机数”的角色与区别

首先，我们必须明确区分握手过程中出现的三个关键数据：`Client Random`、`Server Random` 和 `Pre-Master Secret`。把它们想象成制作一道秘制酱料的**三种核心原料**。

1. **`Client Random` (客户端随机数)**
    
    - **角色**: 公开的原料 A。
    - **产生时间**: `ClientHello` 阶段。
    - **特点**: 在网络上**明文传输**，所有中间人都能看到。它的主要作用是为最终密钥的生成提供随机性，并且**防止重放攻击**。因为每次连接的这个值都不同，攻击者无法截获一次会话的数据，然后原封不动地在另一次会话中“重放”来欺骗服务器。
2. **`Server Random` (服务器随机数)**
    
    - **角色**: 公开的原料 B。
    - **产生时间**: `ServerHello` 阶段。
    - **特点**: 同样在网络上**明文传输**，作用与 `Client Random` 类似，为密钥生成提供另一半的公开随机性，并共同防止重放攻击。
3. **`Pre-Master Secret` (预主密钥) - 你提到的“种子”**
    
    - **角色**: **秘密的原料 C**。这是整个配方中最关键、最需要保密的成分。
    - **产生时间**: 客户端在第 6 步 `ClientKeyExchange` 之前生成。
    - **特点**: **它绝不会明文传输**。客户端会用之前从服务器证书中获得的**公钥**将其加密，然后才发送出去。只有拥有对应**私钥**的服务器才能解密得到它。**这是整个密钥交换安全性的基石**。

**核心区别总结**:  
`Client Random` 和 `Server Random` 是公开的，它们保证了每次会话的独一无二性。而 `Pre-Master Secret` 是秘密的，它提供了只有通信双方才知道的关键信息。**最终的会话密钥，是由这三者共同混合生成的。** 缺一不可，且任何第三方都无法同时获得这三样东西（因为 `Pre-Master Secret` 是加密的）。

---

### 二、密钥是如何计算出来的？（解答你的核心疑问）

你的问题是：“为什么第六步还在说生成一个创建会话密钥的种子，第七步就已用上了密钥？所以说第六步中客户端还会直接计算得到密钥吗？”

**答案是：是的，完全正确！**

客户端在第 6 步**发送完 `ClientKeyExchange` 消息后，就立即在本地进行密钥计算了**。它不需要等待服务器的任何回应。

让我们把这个过程想象成一个“厨房料理”的流程：

**料理准备阶段**

- 客户端有了：`Client Random` (原料A), `Server Random` (原料B), `Pre-Master Secret` (原料C)。
- 服务器有了：`Client Random` (原料A), `Server Random` (原料B)。它正在等待客户端把锁在保险箱里的 `Pre-Master Secret` (原料C) 送过来。

**客户端的料理过程 (发生在第6步之后，第7步之前)**

1. **生成主密钥 (Master Secret)**:  
    客户端调用一个名为 **PRF (Pseudo-Random Function，伪随机函数)** 的算法。在 TLS 1.2 中，这通常是基于 HMAC-SHA256 的算法。  
    它将三个原料混合在一起，生成一个 48 字节的 `Master Secret`。  
    公式可以简化理解为：  
    `Master Secret = PRF(Pre-Master Secret, "master secret", Client Random + Server Random)`
    
    - `Pre-Master Secret`: 秘密原料。
    - `"master secret"`: 一个固定的标签字符串，确保生成的密钥用于此特定目的。
    - `Client Random + Server Random`: 两个公开原料拼接在一起。
2. **派生会话密钥 (Session Keys)**:  
    `Master Secret` 本身还不是最终用于加密应用数据的密钥。它像一个“密钥母体”，需要进一步派生出真正干活的“工作密钥”。客户端再次使用 PRF 函数，这次用 `Master Secret` 作为输入：  
    公式可以简化理解为：  
    `Key Block = PRF(Master Secret, "key expansion", Server Random + Client Random)`
    
    - `Master Secret`: 刚刚生成的密钥母体。
    - `"key expansion"`: 另一个固定的标签字符串。
    - `Server Random + Client Random`: 再次引入随机数，增加随机性。
    
    这个 `Key Block` 是一长串的伪随机字节。然后，客户端根据之前在 `ServerHello` 中协商好的加密套件，像切蛋糕一样从这个 `Key Block` 中按顺序切出所需的各种密钥：
    
    - 客户端加密密钥 (Client Write Key)
    - 服务器加密密钥 (Server Write Key)
    - 客户端消息认证码密钥 (Client Write MAC Key)
    - 服务器消息认证码密钥 (Server Write MAC Key)
    - (如果需要) 客户端初始化向量 (Client Write IV)
    - (如果需要) 服务器初始化向量 (Server Write IV)

**至此，客户端已经拥有了所有加密通信所需的密钥！** 这个过程完全在客户端本地完成，速度极快。

---

### 三、完整时间线梳理

现在我们把密钥计算的步骤放回到完整的握手时间线中，你就会豁然开朗：

- **第 1-5 步**: 客户端和服务器交换 `Hello` 消息和证书。
    
    - **结果**: 客户端获得了 `Client Random`、`Server Random` 和服务器的公钥。
- **第 6 步: `ClientKeyExchange`**
    
    1. 客户端生成 `Pre-Master Secret` (秘密原料C)。
    2. 客户端用服务器的公钥加密 `Pre-Master Secret`。
    3. 客户端将加密后的 `Pre-Master Secret` 发送给服务器。
    4. **【关键点】**: 在消息**发送出去之后**，客户端**立即**执行我们上面描述的“料理过程”，在本地计算出 `Master Secret` 和所有的 `Session Keys`。
- **第 7 步: `ChangeCipherSpec`**
    
    - 因为客户端在第 6 步后已经算好了所有密钥，所以它现在可以理直气壮地告诉服务器：“我准备好了，下一条消息我就要用新密钥加密了！”
- **第 8 步: `Finished`**
    
    - 客户端发送 `Finished` 消息。这条消息的内容是之前所有握手消息的哈希值，然后用刚刚生成的**会话密钥 (Client Write Key)** 进行加密。这是客户端发出的第一条加密消息，也是对整个密钥计算过程的验证。
- **服务器端在做什么？**
    
    1. 服务器收到第 6 步的 `ClientKeyExchange` 消息。
    2. 它用自己的**私钥**解密，得到 `Pre-Master Secret` (秘密原料C)。
    3. **【服务器的关键点】**: 此时，服务器也集齐了三样原料 (`Client Random`, `Server Random`, `Pre-Master Secret`)。它立刻执行**与客户端完全相同**的“料理过程”，计算出 `Master Secret` 和所有的 `Session Keys`。
    4. 服务器收到第 7 步的 `ChangeCipherSpec`，它知道下一条消息是加密的。
    5. 服务器收到第 8 步的 `Finished` 消息，它使用自己刚刚生成的**会话密钥 (Client Write Key)** 尝试解密。如果解密成功，并且哈希值能对上，就证明客户端的密钥计算是正确的，且握手过程未被篡改。

之后，服务器也会发送自己的 `ChangeCipherSpec` 和 `Finished` 消息，让客户端进行同样的验证。

**总结**: 客户端和服务器就像两个拥有相同秘方和部分公开原料的厨师。当客户端通过一个绝对安全的方式（公钥加密）将最后一份秘密原料递送给服务器后，双方就可以**各自在自己的厨房里，独立、并行地**烹饪出完全相同的最终酱料（会话密钥）。这就是为什么第 6 步之后，客户端能立刻进入加密状态的原因。