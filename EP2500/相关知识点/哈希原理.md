SHA-256（Secure Hash Algorithm 256-bit）之所以能够将任意长度的输入转换为固定长度（256位，即32字节）的输出，是因为它采用了**Merkle-Damgård 结构**（或类似的迭代压缩结构）以及**填充（Padding）**机制。

简单来说，它就像一个“绞肉机”，无论你塞进去是一块肉还是一头牛，它都会先把肉切成同样大小的小块，然后一块一块地处理，最终压缩成一个固定大小的“精华”。

以下是其核心机制的详细步骤解析：

### 1. 预处理：填充与长度附加（Padding & Length Appending）

这是确保数据符合处理要求的关键第一步。SHA-256 处理数据的基本单位是 **512位（64字节）** 的“块”（Block）。

如果输入的数据长度不是512位的倍数（绝大多数情况都不是），算法必须对其进行填充，使其长度刚好是512位的倍数。

- **补位（Padding）：**
    1. 先在消息末尾补一个 `1`（二进制）。
    2. 然后补很多个 `0`，直到消息长度满足：`长度 % 512 = 448`。也就是说，距离下一个512位的倍数还差64位。
- **附加长度（Length Appending）：**
    - 在剩下的最后64位中，填入原始消息的长度（二进制表示）。

**结果：** 无论原始输入是 "abc" 还是 10GB 的电影文件，经过这一步后，数据都被变成了一个长度为 $N \times 512$ 位的长比特流。数据被完美地切分成了 $N$ 个 512 位的块（$M_1, M_2, ..., M_N$）。

### 2. 初始化缓冲区（Initialization Vector）

算法开始时，需要一组固定的初始值作为计算的起点。SHA-256 使用 8 个 32 位的寄存器（$H_0$ 到 $H_7$）。

这些初始值是固定的常数（取自前8个素数的平方根的小数部分的前32位），不管输入是什么，起点永远是一样的。

### 3. 迭代压缩（Compression Function）

这是产生固定长度输出的核心魔法。算法使用一个循环，依次处理每一个 512 位的块。

- **输入：** 上一轮的计算结果（256位的哈希值） + 当前要处理的 512 位数据块。
    
- **过程：**
    
    1. **消息扩展（Message Schedule）：** 将 512 位（64字节）的数据块扩展为 64 个 32 位的字（Words），记为 $W_0$ 到 $W_{63}$。
    2. **主循环（The Main Loop）：** 进行 64 轮加密运算。每一轮都会利用当前的 $W_t$ 和一系列复杂的逻辑函数（位移、异或、旋转等）来搅乱和混合那 8 个寄存器（$a, b, c, d, e, f, g, h$）的值。
    3. **更新哈希值：** 64轮运算结束后，将当前的寄存器值与上一轮的哈希值相加（模 $2^{32}$ 加法），得到新的哈希值。
- **输出：** 一个新的 256 位哈希值。
    

**关键点：** 这个过程是链式的。

- 处理第 1 个块时，结合初始向量，算出一个中间哈希值。
- 处理第 2 个块时，使用第 1 个块产生的中间哈希值作为基础，再结合第 2 个块的数据进行计算。
- ...
- 处理第 $N$ 个块时，使用第 $N-1$ 个块的结果。

### 4. 最终输出

当最后一个数据块（$M_N$）处理完毕后，寄存器中剩下的 8 个 32 位数值拼接在一起，就是最终的 256 位（32字节）哈希值。

---

### 总结：为什么长度固定？

1. **固定大小的容器：** 算法内部始终只维护 8 个 32 位的变量（共256位）。无论处理多少数据，这 8 个变量只是不断地被更新数值，而不会增加数量。
2. **分块处理：** 无论输入多长，都被切成了标准的 512 位小块。算法只是在一个循环里不断地“吃掉”这些块来更新那 8 个变量。
3. **丢弃历史：** 每处理完一个块，原始数据就不再需要了，只保留计算后的“摘要”进入下一轮。

因此，当循环结束时，你得到的永远是那 8 个 32 位变量的最终状态，即固定的 256 位。

---
