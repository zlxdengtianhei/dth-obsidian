非对称加密（Asymmetric Cryptography），也称为**公钥密码学**，是现代互联网安全的基石。

与对称加密（只有一把钥匙）不同，非对称加密有**两把钥匙**：

1. **公钥 (Public Key)**：公开给所有人，用于**加密**数据或**验证**签名。
2. **私钥 (Private Key)**：只有自己保留，绝不能泄露，用于**解密**数据或**生成**签名。

**核心逻辑**：公钥加密的数据，只有私钥能解开；私钥签名的数据，公钥能验证是谁签的。

下面介绍最经典的两种算法：**RSA** 和 **ECC**，以及它们背后的数学计算原理。

---
# 深入解析：RSA 与 ECC 的底层计算细节

你已经了解了宏观原理，下面我们将深入到**算法实现的微观层面**。计算机在处理这些加密算法时，并不是简单的“乘法”或“加法”，而是使用了一套高效的数论算法。

## 一、 RSA 的详细计算过程

RSA 的核心在于**模幂运算（Modular Exponentiation）**和**模逆元（Modular Multiplicative Inverse）**的计算。

### 1. 密钥生成中的核心计算：如何算出私钥 $d$？

在生成密钥时，最关键的一步是：已知 $e$ 和 $\phi(N)$，求 $d$，使得：  
$e×d≡1(modϕ(N))e \times d \equiv 1 \pmod{\phi(N)}e×d≡1(modϕ(N))$

这在数学上被称为求 $e$ 关于模 $\phi(N)$ 的**乘法逆元**。计算机不会通过穷举来算，而是使用 **扩展欧几里得算法 (Extended Euclidean Algorithm)**。

$\phi(N)$ 的定义是：**在小于等于 $N$ 的正整数中，有多少个数字与 $N$ 构成“互质”关系？**

### RSA 中 $\phi(N)$ 与 $N$ 的特殊关系

在 RSA 中，$N$ 不是随便选的，它是由两个大质数 $p$ 和 $q$ 相乘得到的：  
$N = p \times q$

欧拉函数有一个非常重要的数学性质（**积性函数**）：如果 $p$ 和 $q$ 互质，那么乘积的欧拉函数等于它们各自欧拉函数的乘积。

所以，RSA 中的 $\phi(N)$ 计算公式极其简单：  
$\phi(N) = \phi(p) \times \phi(q) = (p - 1)(q - 1)$

**计算逻辑：**  
我们需要找到整数 $d$ 和 $k$，满足方程：  
$e \times d + \phi(N) \times k = \gcd(e, \phi(N)) = 1$

通过辗转相除法的逆运算，可以快速找到 $d$。

> **举个迷你例子：**  
> 假设 $p=61, q=53$，则 $N=3233$，$\phi(N)=60 \times 52 = 3120$。  
> 假设公钥 $e=17$。  
> 我们要求 $d$，使得 $17d \equiv 1 \pmod{3120}$。
> 
> 计算机运行扩展欧几里得算法后，会得出 $d=2753$。  
> 验证：$17 \times 2753 = 46801$。  
> $46801 \div 3120 = 15$ 余 $1$。正确。

### 2. 加密与解密的核心计算：模幂运算

加密公式是 $C \equiv M^e \pmod N$。  
如果 $M$ 是一个很大的数，而 $e$ 是 65537，直接计算 $M^{65537}$ 会产生一个天文数字，内存根本装不下。

计算机使用的是 **“平方-乘”算法 (Square-and-Multiply Algorithm)**，也叫**快速幂**。

**计算逻辑：**

1. 将指数 $e$ 转换为二进制形式。
2. 从底数 $M$ 开始，不断地做平方运算。
3. 如果二进制位是 1，就多乘一次底数。
4. **关键点**：每一步运算后，立刻对 $N$ 取模（取余数）。这样数字永远不会超过 $N$ 的大小。

**公式化描述：**  
假设我们要算 $5^{13} \pmod{100}$。

1. 指数 $13$ 的二进制是 $1101_2$。
2. $5^{13} = 5^{8} \times 5^{4} \times 5^{1}$。
3. 计算过程：
    - $5^1 \equiv 5$
    - $5^2 \equiv 25$
    - $5^4 \equiv 25^2 = 625 \equiv 25 \pmod{100}$
    - $5^8 \equiv 25^2 = 625 \equiv 25 \pmod{100}$
    - 结果 $= 5^8 \times 5^4 \times 5^1 \equiv 25 \times 25 \times 5 \equiv 3125 \equiv 25 \pmod{100}$

RSA 实际上就是对 2048 位的超大整数做这种循环运算。

---

## 二、 ECC 的详细计算过程

ECC 的计算比 RSA 复杂得多，它不是简单的数字乘除，而是**几何坐标的代数运算**。所有的运算都是在有限域 $F_p$ 上进行的（即所有加减乘除结果都要对一个大质数 $p$ 取模）。

### 1. 椭圆曲线方程

标准的 Weierstrass 方程形式如下：  
y2≡x3+ax+b(modp)y^2 \equiv x^3 + ax + b \pmod py2≡x3+ax+b(modp)

### 2. 核心运算：点加 (Point Addition) 与 点倍 (Point Doubling)

在 ECC 中，所谓的“加法” $P + Q = R$ 并不是坐标直接相加，而是有一套代数公式。

设点 $P = (x_1, y_1)$，点 $Q = (x_2, y_2)$，计算结果 $R = (x_3, y_3)$。

#### 情况 A：点加 (Point Addition)，当 $P \neq Q$ 时

几何意义是连接 $P, Q$ 的直线与曲线交于第三点，然后关于 X 轴对称。  
代数计算步骤：

1. **计算斜率 $\lambda$ (Lambda)：**  
    $\lambda = \frac{y_2 - y_1}{x_2 - x_1} \pmod p$
    _(注意：这里的除法是模逆元运算)_
    
2. **计算新坐标：**  
    $x_3 = \lambda^2 - x_1 - x_2 \pmod p$  
    $y_3 = \lambda(x_1 - x_3) - y_1 \pmod p$
    

#### 情况 B：点倍 (Point Doubling)，当 $P = Q$ 时

这是计算 $P + P = 2P$。几何意义是作 $P$ 点的切线。  
代数计算步骤：

1. **计算切线斜率 $\lambda$：**  
    $\lambda = \frac{3x_1^2 + a}{2y_1} \pmod p$
    
2. **计算新坐标：**  
    $x_3 = \lambda^2 - 2x_1 \pmod p$  
    $y_3 = \lambda(x_1 - x_3) - y_1 \pmod p$
    

### 3. 公钥生成与加密的核心：标量乘法 (Scalar Multiplication)

生成公钥或进行 ECDH 交换时，我们需要计算 $K = k \times G$（$G$ 加自己 $k$ 次）。  
这里的 $k$ 是一个巨大的 256 位整数。如果做 $k$ 次加法，计算机算到宇宙毁灭也算不完。

计算机使用的是 **“加倍-加”算法 (Double-and-Add Algorithm)**，逻辑与 RSA 的快速幂非常像。

**计算逻辑：**  
假设我们要算 $151 \times G$。

1. 将 $151$ 转为二进制：$10010111_2$。
2. 运算分解为：  
    151G=(2(2(2(2(2(2(2G)+0)+0)+G)+0)+G)+G)+G151G = (2(2(2(2(2(2(2G) + 0) + 0) + G) + 0) + G) + G) + G151G=(2(2(2(2(2(2(2G)+0)+0)+G)+0)+G)+G)+G  
    _(这是霍纳法则的变体)_
3. 计算机只需要做 7 次“点倍”运算和 4 次“点加”运算即可完成，而不是做 151 次运算。

### 4. ECC 如何进行“加密”？(ECIES)

你提到了 ECC 通常用于密钥交换，但如果非要用它加密数据（例如 ECIES - Elliptic Curve Integrated Encryption Scheme），流程如下：

假设 Alice 要发消息 $M$ 给 Bob（Bob 公钥为 $B$）。

1. **生成临时密钥**：Alice 随机生成一个临时私钥 $r$，计算临时公钥 $R = r \times G$。
2. **生成共享秘密**：Alice 计算共享点 $S = r \times B$。这个点 $S$ 的坐标 $(S_x, S_y)$ 就是秘密。
3. **派生密钥**：将 $S_x$ 输入哈希函数（如 SHA-256），生成对称加密密钥 $K_{enc}$。
4. **对称加密**：使用 $K_{enc}$ 对明文 $M$ 进行 AES 加密，得到密文 $C$。
5. **发送**：Alice 将 $(R, C)$ 发送给 Bob。

**Bob 解密计算：**

1. 收到 $(R, C)$。
2. 利用自己的私钥 $b$，计算 $S' = b \times R$。
    - 数学原理：$b \times R = b \times (r \times G) = r \times (b \times G) = r \times B = S$。
3. Bob 算出了完全一样的点 $S$。
4. Bob 对 $S_x$ 进行哈希，得到同样的 $K_{enc}$，解开 AES 密文。
---

### 一、 RSA 的详细计算过程

RSA 的核心运算是**模幂运算（Modular Exponentiation）**。虽然公式写起来是 C=Me(modN)C = M^e \pmod NC=Me(modN)，但在计算机里，绝对不是先算出 MeM^eMe（这个数大到内存装不下）再去取模，而是使用了一种叫做**“平方-乘（Square-and-Multiply）”**的算法。

#### 1. 密钥生成中的关键计算：扩展欧几里得算法

在生成私钥 ddd 时，我们需要解这个方程：  
d×e≡1(modϕ(N))d \times e \equiv 1 \pmod{\phi(N)}d×e≡1(modϕ(N))

这等价于寻找一个整数 kkk，使得：  
d×e=k×ϕ(N)+1d \times e = k \times \phi(N) + 1d×e=k×ϕ(N)+1  
或者变形为：  
d×e−k×ϕ(N)=1d \times e - k \times \phi(N) = 1d×e−k×ϕ(N)=1

计算机使用 **扩展欧几里得算法 (Extended Euclidean Algorithm)** 来求解 ddd。它通过不断地进行带余除法，逆向推导出系数 ddd。

#### 2. 加密与解密的核心：快速模幂算法

假设我们要计算 C=Me(modN)C = M^e \pmod NC=Me(modN)。  
如果 MMM 是一个 2048 位的整数，eee 是 65537，直接算 M65537M^{65537}M65537 是不可能的。

**计算机是这样算的（二进制拆分法）：**

1. 将指数 eee 转换为二进制形式。  
    例如，假设 e=13e = 13e=13，二进制是 110121101_211012​。  
    M13=M8×M4×M1M^{13} = M^{8} \times M^{4} \times M^{1}M13=M8×M4×M1
2. 计算机通过不断的**“平方”**和**“取模”**来得到这些项，而不是硬乘。

**具体步骤演示（计算 M13(modN)M^{13} \pmod NM13(modN)）：**

- **初始化：** 结果 Result=1Result = 1Result=1，底数 Base=MBase = MBase=M。
- **第 1 位（最低位，1）：** 需要乘。Result=(Result×Base)(modN)Result = (Result \times Base) \pmod NResult=(Result×Base)(modN)。
- **准备下一位：** Base=(Base×Base)(modN)Base = (Base \times Base) \pmod NBase=(Base×Base)(modN) （此时 Base 变成了 M2M^2M2）。
- **第 2 位（0）：** 不需要乘。
- **准备下一位：** Base=(Base×Base)(modN)Base = (Base \times Base) \pmod NBase=(Base×Base)(modN) （此时 Base 变成了 M4M^4M4）。
- **第 3 位（1）：** 需要乘。Result=(Result×Base)(modN)Result = (Result \times Base) \pmod NResult=(Result×Base)(modN) （乘入了 M4M^4M4）。
- **准备下一位：** Base=(Base×Base)(modN)Base = (Base \times Base) \pmod NBase=(Base×Base)(modN) （此时 Base 变成了 M8M^8M8）。
- **第 4 位（1）：** 需要乘。Result=(Result×Base)(modN)Result = (Result \times Base) \pmod NResult=(Result×Base)(modN) （乘入了 M8M^8M8）。

**最终结果：** Result=M1×M4×M8=M13(modN)Result = M^1 \times M^4 \times M^8 = M^{13} \pmod NResult=M1×M4×M8=M13(modN)。

**总结：** RSA 的计算本质上就是几千次的大整数乘法和取余运算。

---

### 二、 ECC 的详细计算过程

ECC 的计算完全不同，它不是处理大整数的幂，而是处理**坐标点 (x,y)(x, y)(x,y) 的几何加法**。所有的运算都是在一个有限域 Fp\mathbb{F}_pFp​ 上进行的，这意味着所有的加减乘除最后都要对一个大质数 ppp 取模。

椭圆曲线方程通常形式为（Weierstrass 方程）：  
y2≡x3+ax+b(modp)y^2 \equiv x^3 + ax + b \pmod py2≡x3+ax+b(modp)

#### 1. 核心运算：点加法 (Point Addition)

在 ECC 中，计算 P+Q=RP + Q = RP+Q=R 并不是简单的坐标相加 (xp+xq,yp+yq)(x_p+x_q, y_p+y_q)(xp​+xq​,yp​+yq​)，而是基于几何规则的代数公式。

假设点 P=(x1,y1)P = (x_1, y_1)P=(x1​,y1​)，点 Q=(x2,y2)Q = (x_2, y_2)Q=(x2​,y2​)，我们要算 R=(x3,y3)R = (x_3, y_3)R=(x3​,y3​)。

**情况 A：点加 (Point Addition, P≠QP \neq QP=Q)**  
几何意义：连接 PPP 和 QQQ 的直线与曲线相交于第三点，该点关于 X 轴的对称点就是 RRR。

1. **计算斜率 λ\lambdaλ (Slope)：**  
    λ=y2−y1x2−x1(modp)\lambda = \frac{y_2 - y_1}{x_2 - x_1} \pmod pλ=x2​−x1​y2​−y1​​(modp)  
    _(注意：这里的除法在计算机中是计算“模逆元”，即乘以 (x2−x1)−1(modp)(x_2 - x_1)^{-1} \pmod p(x2​−x1​)−1(modp))_
    
2. **计算 x3x_3x3​：**  
    x3=λ2−x1−x2(modp)x_3 = \lambda^2 - x_1 - x_2 \pmod px3​=λ2−x1​−x2​(modp)
    
3. **计算 y3y_3y3​：**  
    y3=λ(x1−x3)−y1(modp)y_3 = \lambda(x_1 - x_3) - y_1 \pmod py3​=λ(x1​−x3​)−y1​(modp)
    

**情况 B：倍点 (Point Doubling, P=QP = QP=Q)**  
这是 ECC 最常用的运算（因为算 k×Gk \times Gk×G 主要靠倍点）。  
几何意义：作 PPP 点的切线，切线与曲线交于另一点，其对称点为 2P2P2P。

1. **计算切线斜率 λ\lambdaλ：**  
    我们要对曲线方程求导来算斜率：  
    λ=3x12+a2y1(modp)\lambda = \frac{3x_1^2 + a}{2y_1} \pmod pλ=2y1​3x12​+a​(modp)
    
2. **计算 x3x_3x3​：**  
    x3=λ2−2x1(modp)x_3 = \lambda^2 - 2x_1 \pmod px3​=λ2−2x1​(modp)
    
3. **计算 y3y_3y3​：**  
    y3=λ(x1−x3)−y1(modp)y_3 = \lambda(x_1 - x_3) - y_1 \pmod py3​=λ(x1​−x3​)−y1​(modp)
    

#### 2. 公钥生成与加密：标量乘法 (Scalar Multiplication)

我们要计算公钥 K=k×GK = k \times GK=k×G（GGG 是基点，kkk 是私钥大整数）。  
这**绝对不是**做 kkk 次加法（如果 kkk 是 22562^{256}2256，那宇宙毁灭也算不完）。

计算机使用 **“双倍-加（Double-and-Add）”** 算法，逻辑和 RSA 的“平方-乘”非常像。

**具体步骤演示（计算 5×G5 \times G5×G）：**  
555 的二进制是 1012101_21012​。  
5G=1⋅(4G)+0⋅(2G)+1⋅(1G)5G = 1 \cdot (4G) + 0 \cdot (2G) + 1 \cdot (1G)5G=1⋅(4G)+0⋅(2G)+1⋅(1G)

1. **初始化：** 结果点 R=无穷远点R = \text{无穷远点}R=无穷远点 (类似于 0)，临时点 T=GT = GT=G。
2. **第 1 位（最低位，1）：** 需要加。R=R+TR = R + TR=R+T (现在 R=GR=GR=G)。
3. **翻倍临时点：** T=T+T=2GT = T + T = 2GT=T+T=2G (使用上面的倍点公式)。
4. **第 2 位（0）：** 不需要加。
5. **翻倍临时点：** T=T+T=4GT = T + T = 4GT=T+T=4G。
6. **第 3 位（1）：** 需要加。R=R+TR = R + TR=R+T (即 G+4G=5GG + 4G = 5GG+4G=5G)。

**总结：** ECC 的一次“加密”（或公钥生成），本质上是进行了约 256 次的“点加”和“倍点”运算。

---

### 三、 为什么 ECC 比 RSA 更难破解？（算力对比）

为了达到同等的安全级别（例如 128 位安全强度）：

1. **RSA** 需要 3072 位的模数 NNN。
    
    - 攻击者需要分解这个 3072 位的大整数。
    - 目前最快的分解算法（数域筛选法 GNFS）虽然很难，但随着数字变大，它的破解难度增加得**不够快**（亚指数级）。所以 RSA 密钥必须非常长才能抵御。
2. **ECC** 只需要 256 位的私钥 kkk。
    
    - 攻击者需要解“椭圆曲线离散对数问题”。
    - 目前已知的最快破解算法（Pollard's rho 算法）是完全指数级的难度。也就是说，每增加 1 位密钥长度，破解难度真的就是翻倍。
    - 因此，ECC 可以用很短的钥匙，达到 RSA 极长钥匙才能达到的安全性。

### 四、 实际应用中的公式渲染总结

在 Markdown 中，上述公式的渲染依赖于 MathJax 或 KaTeX 引擎。

- **RSA 加密：**  
    C=Me(modN)C = M^e \pmod NC=Me(modN)
- **RSA 解密：**  
    M=Cd(modN)M = C^d \pmod NM=Cd(modN)
- **ECC 曲线方程：**  
    y2≡x3+ax+b(modp)y^2 \equiv x^3 + ax + b \pmod py2≡x3+ax+b(modp)
- **ECC 公钥生成：**  
    K=G+G+⋯+G⏟k times=k⋅GK = \underbrace{G + G + \dots + G}_{k \text{ times}} = k \cdot GK=k timesG+G+⋯+G​​=k⋅G
---

### 三、 总结与对比：当前世界的现状

在当前的加密世界中，非对称加密主要用于两个场景：

1. **身份认证与签名**：证明“我是我”。
2. **密钥协商**：安全地交换“对称加密的密钥”。（因为非对称太慢，不适合直接加密大文件）。

|特性|RSA|ECC (椭圆曲线)|
|---|---|---|
|**原理**|大整数分解|椭圆曲线离散对数|
|**密钥长度**|长 (2048位 ~ 4096位)|短 (256位 ~ 384位)|
|**运算速度**|较慢 (尤其是解密和生成密钥)|极快 (计算量小，省电)|
|**安全性**|极高 (但需要很长的密钥)|极高 (同等长度下远超 RSA)|
|**应用现状**|**老当益壮**。银行盾、旧系统、简单的证书签名。|**当红炸子鸡**。HTTPS (TLS 1.3)、区块链 (比特币/以太坊)、即时通讯 (WhatsApp/Signal)。|
|**未来威胁**|量子计算机可以快速破解 (Shor算法)|量子计算机可以快速破解|

**补充：未来的算法（后量子密码学 PQC）**  
因为 RSA 和 ECC 都会被未来的量子计算机破解，目前世界正在向 **PQC (Post-Quantum Cryptography)** 迁移。这些算法基于**格密码 (Lattice-based)** 等更复杂的数学难题，比如 Kyber 和 Dilithium 算法，它们既不是 RSA 也不是 ECC。

**一句话总结：**  
如果把加密比作锁，**AES** 是那把锁住数据的铁锁，而 **RSA/ECC** 则是用来安全地把铁锁的钥匙快递给对方的保险箱。目前，**ECC** 因为短小精悍，正在全面取代 RSA 的地位。