### 方案一：HMAC (Hash-based Message Authentication Code) —— 工业标准

这是目前 Web 开发、API 签名中最常用的解决方案。它不需要更换哈希算法（你依然可以用 MD5 或 SHA-256），而是改变了**拼装数据的方式**。

#### 原理：双重哈希（嵌套哈希）

之前的错误做法是：`Hash(Key + Message)`。  
HMAC 的做法可以简单理解为：**`Hash(Key + Hash(Key + Message))`**。

_(注：实际标准稍微复杂一点，引入了 `ipad` 和 `opad` 两个常量来处理 Key，但核心逻辑就是双重哈希)_

#### 为什么这样能防住攻击？

让我们回到攻击者的视角：

1. **内层哈希**：`Hash(Key + Message)`。  
    攻击者依然可以通过长度扩展攻击，算出 `Hash(Key + Message + Padding + 恶意数据)` 的值。  
    **但是！** 这个值现在只是个中间结果，服务器并不会直接把这个值作为最终签名发出来。
    
2. **外层哈希**：`Hash(Key + 内层结果)`。  
    服务器最终发出来的签名，是经过外层哈希“封包”后的结果。
    
    - 攻击者手里拿到的是 **外层哈希的结果**。
    - 攻击者想做长度扩展，他必须知道 **外层哈希计算结束时的内部状态**。
    - 要复原这个状态，他得知道外层计算时输入了什么。
    - 外层输入的是 `Key`！攻击者没有 Key。

**比喻：**  
之前的做法是写完信（Message）直接盖个章（Hash），攻击者可以在信纸下面接着写，然后利用章的印记伪造。  
HMAC 的做法是：先把信和 Key 放在一起拍张照（内层 Hash），然后把这张**照片**和 Key 放在一起，再拍一张照（外层 Hash）。攻击者拿到的只是第二张照片，他无法在第一张照片的画面里“继续写字”。

---

### 方案二：截断输出 (Truncated Hash) —— 简单粗暴

如果攻击者需要“完整的内部状态”才能继续计算，那我就**不给你完整的状态**。

#### 原理

很多现代哈希算法都有“截断版”。  
比如 **SHA-384**。  
你可能以为 SHA-384 是一个独立的算法，其实不是。它本质上是 **SHA-512** 的运算逻辑：

1. 使用 SHA-512 的算法跑完全程。
2. 内部状态有 512 位（64字节）。
3. **扔掉**最后 128 位，只输出前 384 位。

#### 为什么这样能防住攻击？

攻击者拿到了 384 位的哈希值。  
但是，要恢复 SHA-512 的计算状态，需要完整的 512 位寄存器值。  
攻击者缺失了 128 位的信息（约 $3.4 \times 10^{38}$ 种可能性）。他无法猜出这缺失的部分，也就无法初始化他本地的哈希程序来接力计算。

_常见的截断算法：SHA-384 (基于SHA-512), SHA-512/256 (基于SHA-512但输出256位)。_

---

### 方案三：SHA-3 (Keccak) —— 彻底换代

SHA-3 是 2015 年发布的最新标准。它从底层结构上就抛弃了 Merkle-Damgård 结构，采用了一种叫 **海绵结构 (Sponge Construction)** 的机制。

#### 原理：容量 (Capacity) 与 速率 (Rate)

SHA-3 的内部状态非常大（比如 1600 位），它把状态分为两部分：

1. **Rate (速率部分)**：这部分数据会与输入数据进行异或（吸收数据），也会被输出（挤出哈希值）。
2. **Capacity (容量部分)**：这部分数据**永远不直接输出**，只参与内部的混乱计算。

#### 为什么这样能防住攻击？

在 Merkle-Damgård (MD5/SHA2) 中，输出的哈希值 = 整个内部状态。  
在 SHA-3 中，**输出的哈希值 < 整个内部状态**。

攻击者只能看到 Rate 部分的状态，永远看不到 Capacity 部分的状态。  
因为缺失了 Capacity 这部分关键的内部数据，攻击者根本无法还原出算法当前的“完整状态”，自然也就无法进行长度扩展攻击。

---

### 总结：如何选择？

|方案|适用场景|评价|
|---|---|---|
|**HMAC**|**最推荐**。适用于所有现有系统。|即使你还在用 MD5（虽然不推荐），加上 HMAC 后也能防住长度扩展攻击。它是标准做法，几乎所有编程语言库都支持。|
|**SHA-2 截断版**|适用于新系统开发。|比如使用 SHA-384 或 SHA-512/256。既安全又比 SHA-3 快一点。|
|**SHA-3**|适用于高安全需求的新系统。|从数学原理上彻底根除隐患，但计算速度相对较慢，老旧系统支持度稍差。|

**一句话回答你的问题：**  
现在的开发者根本不需要自己去拼凑字符串（`md5(key+msg)`），而是直接调用库函数 `hmac.new(key, msg, digestmod='sha256')`。只要用了 HMAC，这个问题就彻底解决了。